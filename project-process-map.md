# プロジェクト工程マップ — 「どうやって作るか」

> アジャイル・ウォーターフォール問わず、ソフトウェア開発に共通して必要な工程・タスク・リソース・成果物の網羅的一覧

ソフトウェア開発プロジェクトは、アジャイルであれウォーターフォールであれ、一連の共通した工程を経て進行します。本ドキュメントでは、その各工程で「誰が」「何を使って」「何を行い」「何を作るのか」を体系的にまとめています。プロジェクトの規模や手法に応じて取捨選択しながら活用してください。

## 全体フロー概観

ソフトウェア開発プロジェクトは、大きく8つの工程で構成されます。企画・構想でプロジェクトの方向性を定め、要件定義で「何を作るか」を明確にし、設計で「どう作るか」を決め、実装・テストを経て本番環境へリリースし、その後は運用・保守に移行します。以下の図は、この工程の全体的な流れを示しています。

```mermaid
flowchart LR
    A["1. 企画・構想"] --> B["2. 要件定義"]
    B --> C["3. 基本設計"]
    C --> D["4. 詳細設計"]
    D --> E["5. 実装・開発"]
    E --> F["6. テスト"]
    F --> G["7. デプロイ・リリース"]
    G --> H["8. 運用・保守"]

    style A fill:#4A90D9,color:#fff
    style B fill:#7B68EE,color:#fff
    style C fill:#E67E22,color:#fff
    style D fill:#E67E22,color:#fff
    style E fill:#27AE60,color:#fff
    style F fill:#C0392B,color:#fff
    style G fill:#2C3E50,color:#fff
    style H fill:#16A085,color:#fff
```

## 工程間の関係性と成果物フロー

各工程は独立して存在するのではなく、前工程の成果物が次の工程のインプットになるという依存関係を持っています。たとえば、企画書は要件定義の出発点となり、要件定義書は設計の基盤となります。さらに、提供フェーズでの学びが計画フェーズにフィードバックされることで、プロジェクト全体の質が向上していきます。

```mermaid
flowchart TB
    subgraph PLAN["計画フェーズ"]
        direction TB
        A1["企画書/ビジネスケース"] --> A2["要件定義書"]
    end

    subgraph DESIGN["設計フェーズ"]
        direction TB
        A2 --> B1["基本設計書"]
        B1 --> B2["詳細設計書"]
    end

    subgraph BUILD["構築フェーズ"]
        direction TB
        B2 --> C1["ソースコード"]
        C1 --> C2["テスト結果報告書"]
    end

    subgraph DELIVER["提供フェーズ"]
        direction TB
        C2 --> D1["リリースノート"]
        D1 --> D2["運用マニュアル"]
    end

    DELIVER -.->|"フィードバック"| PLAN
```

## 1. 企画・構想

### 目的

ビジネス上の課題・機会を特定し、ソフトウェア開発プロジェクトとして立ち上げるかどうかを判断する。

企画・構想はプロジェクトの出発点であり、ここでの判断がプロジェクト全体の方向性を決定づけます。「そもそもこのプロジェクトをやるべきか？」を多角的に検討し、ビジネス価値・技術的実現可能性・リソースの見通しを確認したうえで、Go/No-Go の意思決定を行います。ここを雑に進めると、後工程で「そもそも作るべきものではなかった」という手戻りが発生するため、十分な調査と合意形成が不可欠です。

### タスク一覧

この工程のタスクは、技術的なものではなくビジネス分析が中心です。市場調査、競合分析、投資対効果の試算など、経営判断に必要な情報を集めて整理する活動が求められます。エンジニアリングのスキルよりも、ビジネスドメインの知識・分析力・ステークホルダーとの合意形成力が重要になる点が、他の工程と大きく異なります。

| #   | タスク                   | 説明                                                   |
| --- | ------------------------ | ------------------------------------------------------ |
| 1   | ビジネス課題の特定       | 現状分析（As-Is）、あるべき姿（To-Be）のギャップ分析   |
| 2   | 市場・競合調査           | 類似サービス・プロダクトの調査、差別化ポイントの明確化 |
| 3   | フィージビリティスタディ | 技術的実現可能性、法的制約、ビジネス的妥当性の検証     |
| 4   | ステークホルダー分析     | 関係者の洗い出し、影響度・関心度マッピング             |
| 5   | プロジェクト企画書作成   | 目的・ゴール・スコープ・概算見積り・ROI試算            |
| 6   | Go/No-Go判断             | 経営層・意思決定者による承認                           |

### リソース

企画・構想フェーズでは、意思決定権を持つビジネスサイドの人材が中心となります。技術者の関与はフィージビリティ評価に限定されるのが一般的で、開発チーム全体の参加はまだ必要ありません。ツールも市場調査やアイデア整理のためのものが中心で、開発用のツールチェーンはこの段階では不要です。コストは調査費用やPoC費用が主で、開発費と比べると小規模です。

| カテゴリ | リソース                        | 備考                                         |
| -------- | ------------------------------- | -------------------------------------------- |
| **人**   | プロダクトオーナー / 事業責任者 | 意思決定権を持つ人                           |
| **人**   | ビジネスアナリスト              | 課題分析・要求整理                           |
| **人**   | テックリード / CTO              | 技術的実現可能性の評価                       |
| **人**   | UXリサーチャー                  | ユーザーニーズ調査（必要時）                 |
| **物**   | 市場調査ツール                  | SimilarWeb, Google Trends 等                 |
| **物**   | ホワイトボード / Miro / FigJam  | アイデアワークショップ用                     |
| **物**   | ドキュメントツール              | Confluence, Notion, Google Docs 等           |
| **金**   | 調査費用                        | 外部コンサルティング、市場調査レポート購入等 |
| **金**   | PoC費用                         | プロトタイプ開発にかかる工数・インフラ費     |

### 成果物

この工程の成果物は、すべてビジネス判断のための資料です。技術的な設計書ではなく、「なぜこのプロジェクトをやるのか」「投資に見合うリターンがあるか」を説明するドキュメントが中心となります。これらは次工程（要件定義）のインプットとなるだけでなく、プロジェクト期間中に立ち返るべき「原点」にもなります。

| 成果物                         | 形式                | 必須/任意 |
| ------------------------------ | ------------------- | --------- |
| プロジェクト企画書             | ドキュメント        | 必須      |
| ビジネスケース / ROI試算       | スプレッドシート    | 必須      |
| フィージビリティスタディ報告書 | ドキュメント        | 必須      |
| ステークホルダーマップ         | 図表                | 任意      |
| 競合分析レポート               | ドキュメント        | 任意      |
| PoC成果物                      | プロトタイプ / デモ | 任意      |

## 2. 要件定義

### 目的

「何を作るか」を明確にし、ステークホルダー間で合意する。

要件定義は、ビジネス上のニーズをソフトウェアの具体的な仕様へと翻訳する工程です。機能要件（システムが何をすべきか）と非機能要件（どの程度の品質で動くべきか）の両面を定義し、画面イメージやデータ構造の概要も合わせて整理します。要件定義の品質がプロジェクトの成否を大きく左右するため、エンドユーザーやビジネス側との密なコミュニケーションが求められます。曖昧な要件をそのままにすると、設計・実装段階で解釈の食い違いが生じ、大きな手戻りにつながります。

### タスク一覧

要件定義のタスクは、ビジネスの言葉と技術の言葉の「翻訳」作業が中心です。業務フローの可視化、ユースケースの定義、非機能要件の整理など、ビジネスドメインの理解と技術的な実現可能性の両方を橋渡しするスキルが必要です。企画・構想が「やるべきか」を問うのに対し、要件定義は「何をどこまで作るか」を問う工程であり、スコープの線引きと優先順位付けが最も重要な判断ポイントになります。

| #   | タスク                   | 説明                                                         |
| --- | ------------------------ | ------------------------------------------------------------ |
| 1   | 業務フロー分析           | 現行業務のフロー可視化（As-Is）、新業務フローの設計（To-Be） |
| 2   | 機能要件の定義           | ユースケース / ユーザーストーリーの作成                      |
| 3   | 非機能要件の定義         | 性能・可用性・セキュリティ・拡張性等の品質要件               |
| 4   | 画面遷移・UIイメージ作成 | ワイヤーフレーム・モックアップ                               |
| 5   | データ要件の定義         | 扱うデータの種類・量・ライフサイクル                         |
| 6   | 外部インターフェース定義 | 外部システム連携、API仕様の概要                              |
| 7   | 制約・前提条件の整理     | 技術制約・法規制・既存システムとの整合性                     |
| 8   | 受入基準の定義           | 完了条件（Definition of Done）の合意                         |
| 9   | 優先順位付け             | MoSCoW法等による要件の優先度決定                             |
| 10  | 見積り                   | 概算工数・コスト・スケジュールの算出                         |

### リソース

要件定義では、ビジネスサイドと技術サイドの両方の人材が協働する必要があります。プロダクトオーナーやBA（ビジネスアナリスト）が要件を引き出し、アーキテクトが技術的妥当性を評価し、UX/UIデザイナーがユーザー体験を可視化する — この三者の連携が品質を決定づけます。法務・コンプライアンス担当が必要になるのもこの工程の特徴で、法規制要件の見落としは後工程での大幅な手戻りにつながります。ツールは要件管理とプロトタイピングが中心です。

| カテゴリ | リソース                   | 備考                           |
| -------- | -------------------------- | ------------------------------ |
| **人**   | プロダクトオーナー         | 要件の最終決定権               |
| **人**   | ビジネスアナリスト / BA    | 要件の引き出し・文書化         |
| **人**   | UX/UIデザイナー            | ワイヤーフレーム・プロトタイプ |
| **人**   | アーキテクト               | 非機能要件の妥当性評価         |
| **人**   | エンドユーザー代表         | 要件の妥当性検証               |
| **人**   | 法務・コンプライアンス担当 | 法的要件の確認                 |
| **物**   | 要件管理ツール             | Jira, Azure DevOps, Backlog 等 |
| **物**   | プロトタイピングツール     | Figma, Adobe XD, Sketch        |
| **物**   | モデリングツール           | PlantUML, draw.io, Mermaid     |
| **金**   | ユーザー調査費用           | インタビュー、アンケート実施費 |
| **金**   | プロトタイプ制作費用       | デザイナー工数                 |

### 成果物

要件定義の成果物は、開発チームにとっての「契約書」として機能します。要件定義書やユースケース、画面遷移図などは、設計・実装・テストの全工程で繰り返し参照されるため、その正確さと明瞭さが後工程の効率を大きく左右します。非機能要件定義書は、基本設計でのアーキテクチャ判断の直接的な根拠となる重要な成果物です。

| 成果物                              | 形式             | 必須/任意 |
| ----------------------------------- | ---------------- | --------- |
| 要件定義書                          | ドキュメント     | 必須      |
| ユースケース図 / ユーザーストーリー | 図表 / チケット  | 必須      |
| 業務フロー図（As-Is / To-Be）       | フローチャート   | 必須      |
| 画面遷移図                          | 図表             | 必須      |
| ワイヤーフレーム / モックアップ     | デザインファイル | 必須      |
| 非機能要件定義書                    | ドキュメント     | 必須      |
| 用語集 / データディクショナリ       | ドキュメント     | 任意      |
| 概算見積書                          | スプレッドシート | 必須      |

## 3. 基本設計（外部設計）

### 目的

システムの全体構造を決定し、「どう作るか」の大枠を設計する。

基本設計では、要件定義で決まった「何を作るか」を「どう作るか」に変換します。システムアーキテクチャ（モノリスかマイクロサービスか）、技術スタック（言語・フレームワーク・クラウドサービス）、データベースの概念モデル、API の全体方針など、プロジェクトの技術的な骨格をこの段階で決定します。ここでの設計判断は後工程に広範な影響を及ぼすため、ADR（Architecture Decision Records）として判断理由を記録しておくことが重要です。

### タスク一覧

基本設計のタスクは、プロジェクトの中で最も広範な技術領域にまたがります。アーキテクチャ設計、技術スタック選定、UI/UX設計、DB設計、API設計、セキュリティ設計、インフラ設計 — それぞれが異なる専門領域であり、一人のエンジニアがすべてをカバーすることは現実的ではありません。各領域の専門家が協働し、全体としての整合性をアーキテクトが統括するという体制がこの工程では不可欠です。

| #   | タスク                     | 説明                                                       |
| --- | -------------------------- | ---------------------------------------------------------- |
| 1   | システムアーキテクチャ設計 | モノリス / マイクロサービス、層構造、通信方式の決定        |
| 2   | 技術スタック選定           | 言語・フレームワーク・ミドルウェア・クラウドサービスの選定 |
| 3   | UI/UX設計                  | デザインシステム、画面レイアウト、インタラクション設計     |
| 4   | データベース概念設計       | ER図、データモデル（概念レベル）                           |
| 5   | API設計（概要レベル）      | RESTful / GraphQL / gRPC、エンドポイント一覧               |
| 6   | セキュリティ設計           | 認証・認可方式、暗号化、脆弱性対策の方針                   |
| 7   | インフラ設計               | ネットワーク構成、サーバー構成、クラウド設計               |
| 8   | 外部システム連携設計       | 連携先との IF 仕様、プロトコル、データフォーマット         |
| 9   | 性能設計                   | 目標レスポンスタイム、同時接続数、スループット             |
| 10  | 移行設計                   | データ移行方針、並行運用計画                               |

### リソース

基本設計は、全工程中で最も多様な専門家が必要になるフェーズです。システムアーキテクト、フロントエンド/バックエンドのリード、インフラエンジニア、DBエンジニア、セキュリティエンジニア、UI/UXデザイナーと、各領域のリードが一堂に会して全体整合を取ります。企画・構想や要件定義がビジネスサイド中心だったのに対し、ここからは完全に技術サイドが主導します。クラウド検証環境も必要になり、設計の妥当性を実際に検証するコストが発生し始めます。

| カテゴリ | リソース                                         | 備考                             |
| -------- | ------------------------------------------------ | -------------------------------- |
| **人**   | システムアーキテクト                             | 全体設計の責任者                 |
| **人**   | フロントエンドリード                             | UI/UX・フロント技術選定          |
| **人**   | バックエンドリード                               | API・サーバーサイド設計          |
| **人**   | インフラエンジニア / SRE                         | インフラ・クラウド設計           |
| **人**   | DBエンジニア / DBA                               | データベース設計                 |
| **人**   | セキュリティエンジニア                           | セキュリティ設計レビュー         |
| **人**   | UI/UXデザイナー                                  | デザインシステム構築             |
| **物**   | 設計ツール                                       | Figma, draw.io, Lucidchart       |
| **物**   | ADR (Architecture Decision Records) テンプレート | 設計判断の記録用                 |
| **物**   | クラウド検証環境                                 | アーキテクチャ検証用             |
| **金**   | クラウド検証費用                                 | PoC環境のランニングコスト        |
| **金**   | ライセンス費用                                   | 有償ツール・ミドルウェアの評価版 |

### 成果物

基本設計の成果物は、プロジェクトの技術的な「青写真」として、詳細設計と実装の全期間にわたって参照され続けます。特にシステムアーキテクチャ図とADRは、後からチームに参加するメンバーが「なぜこの技術を選んだのか」を理解するための重要な資産です。ここで作成される設計書の粒度は「方針レベル」であり、実装の詳細は次工程（詳細設計）で詰めます。

| 成果物                        | 形式                   | 必須/任意 |
| ----------------------------- | ---------------------- | --------- |
| システムアーキテクチャ図      | 図表（C4モデル等）     | 必須      |
| 技術スタック選定書 / ADR      | ドキュメント           | 必須      |
| 画面設計書 / デザインシステム | デザインファイル       | 必須      |
| ER図（概念モデル）            | 図表                   | 必須      |
| API設計書（概要）             | ドキュメント / OpenAPI | 必須      |
| インフラ構成図                | 図表                   | 必須      |
| セキュリティ設計書            | ドキュメント           | 必須      |
| 性能要件・設計書              | ドキュメント           | 任意      |
| 移行設計書                    | ドキュメント           | 任意      |

## 4. 詳細設計（内部設計）

### 目的

実装に直結するレベルまで設計を詳細化する。

詳細設計は、基本設計で決めた大枠を実装可能なレベルまで具体化する工程です。クラス構成やモジュール分割、テーブル定義、API のリクエスト/レスポンス仕様、エラーハンドリングの方針など、開発者がそのまま実装に着手できる粒度まで落とし込みます。ただし、アジャイル開発では過度に詳細な事前設計を避け、YAGNI（You Aren't Gonna Need It）の原則に従って必要十分な設計に留めることも多いです。

### タスク一覧

詳細設計のタスクは、開発者が直接参照して実装に着手できるレベルの具体性が求められます。クラス図やテーブル定義、APIの入出力仕様など、コードに1対1で対応する粒度です。基本設計が「アーキテクチャの方針」を決めるのに対し、詳細設計は「個々のモジュールの振る舞い」を定義します。テスト設計やコーディング規約の策定もこの段階で行い、実装工程での品質基準を事前に確立する点が特徴的です。

| #   | タスク                      | 説明                                                          |
| --- | --------------------------- | ------------------------------------------------------------- |
| 1   | クラス設計 / モジュール設計 | クラス図、コンポーネント分割、責務の割当て                    |
| 2   | データベース論理・物理設計  | テーブル定義、インデックス設計、パーティション                |
| 3   | API詳細設計                 | リクエスト/レスポンス定義、エラーハンドリング、バリデーション |
| 4   | 画面詳細設計                | コンポーネント設計、状態管理、イベントハンドリング            |
| 5   | バッチ処理設計              | ジョブフロー、スケジュール、リトライ方式                      |
| 6   | シーケンス図作成            | 主要な処理フローの詳細化                                      |
| 7   | エラー設計                  | エラーコード体系、ログ出力方針、例外処理方針                  |
| 8   | テスト設計                  | テスト戦略、テストケース設計の方針                            |
| 9   | コーディング規約策定        | 命名規則、フォーマット、レビュー基準                          |
| 10  | 開発環境構築手順整備        | ローカル開発環境のセットアップ手順                            |

### リソース

詳細設計では、基本設計のような幅広い専門家ではなく、実装に近いシニアエンジニアが主体になります。テックリードが設計品質をレビューし、シニアエンジニアが具体的な設計書を書き、QAエンジニアがテスト設計を監修するという構成です。ツールもIDE、UMLツール、API設計ツールなど、開発に直結するものにシフトします。この段階から開発者が本格的に参加し始めるため、人件費コストが増加し始めるタイミングでもあります。

| カテゴリ | リソース               | 備考                         |
| -------- | ---------------------- | ---------------------------- |
| **人**   | テックリード           | 設計品質のレビュー・判断     |
| **人**   | シニアエンジニア       | 詳細設計の実施               |
| **人**   | DBエンジニア           | DB物理設計                   |
| **人**   | QAエンジニア           | テスト設計の監修             |
| **物**   | IDE / エディタ         | VS Code, IntelliJ 等         |
| **物**   | 設計ドキュメントツール | Markdown, Confluence, Notion |
| **物**   | UMLツール              | PlantUML, Mermaid, draw.io   |
| **物**   | API設計ツール          | Swagger Editor, Stoplight    |
| **金**   | ツールライセンス費     | 有償IDE・設計ツール          |

### 成果物

詳細設計の成果物は、開発者が実装中に日常的に参照する「作業指示書」です。クラス図、テーブル定義書、API仕様書、コーディング規約など、いずれも曖昧さがあると実装者ごとに解釈が分かれ、品質のバラつきにつながります。またOpenAPI/Swagger形式のAPI仕様書は、フロントエンドとバックエンドの並行開発を可能にする「契約」の役割も果たします。

| 成果物                      | 形式                   | 必須/任意 |
| --------------------------- | ---------------------- | --------- |
| 詳細設計書                  | ドキュメント           | 必須      |
| クラス図 / コンポーネント図 | UML図                  | 必須      |
| シーケンス図                | UML図                  | 必須      |
| テーブル定義書              | スプレッドシート / DDL | 必須      |
| API仕様書（詳細）           | OpenAPI / Swagger      | 必須      |
| 画面コンポーネント設計書    | ドキュメント           | 必須      |
| エラーコード一覧            | スプレッドシート       | 任意      |
| コーディング規約            | ドキュメント           | 必須      |
| 開発環境構築手順書          | ドキュメント           | 必須      |

## 5. 実装・開発

### 目的

設計に基づいてソフトウェアを構築する。

実装・開発はプロジェクトの中核であり、通常、最も多くの工数とコストがかかる工程です。開発環境の構築から始まり、フロントエンド・バックエンド・データベース・外部連携の各レイヤーを並行して開発していきます。単にコードを書くだけでなく、単体テストの実装、コードレビューによる品質担保、リファクタリングによる技術的負債の予防も重要な活動です。CI/CD パイプラインを早期に構築し、ビルド・テスト・デプロイの自動化を整備することで、開発効率と品質の両立を図ります。

### タスク一覧

実装・開発のタスクは、他の工程とは質的に異なります。前工程までが「文書を作る」活動だったのに対し、ここでは「動くソフトウェアを作る」活動に転換します。フロントエンド・バックエンド・データベース・外部連携と複数のワークストリームが並行して進むため、タスクの粒度管理とチーム間の調整が重要です。また、単体テスト実装やコードレビューといった品質保証活動が開発と不可分に組み込まれるのも、この工程の特徴です。

| #   | タスク               | 説明                                                     |
| --- | -------------------- | -------------------------------------------------------- |
| 1   | 開発環境セットアップ | リポジトリ作成、CI/CD構築、ローカル環境整備              |
| 2   | プロジェクト初期構築 | スキャフォールディング、ボイラープレート、共通基盤の構築 |
| 3   | フロントエンド実装   | UIコンポーネント開発、画面実装、状態管理                 |
| 4   | バックエンド実装     | API実装、ビジネスロジック、データアクセス層              |
| 5   | データベース構築     | DDL実行、初期データ投入、マイグレーション                |
| 6   | 外部システム連携実装 | API連携、メッセージング、ファイル連携                    |
| 7   | 単体テスト実装       | ユニットテストコードの作成・実行                         |
| 8   | コードレビュー       | プルリクエスト・マージリクエストによるレビュー           |
| 9   | リファクタリング     | コード品質の改善、技術的負債の解消                       |
| 10  | ドキュメント更新     | 実装に合わせた設計書の更新、APIドキュメント自動生成      |

### リソース

実装・開発は、全工程中で最大の人員・ツール・コストを投入するフェーズです。フロントエンド、バックエンド、DevOpsなど専門の異なるエンジニアがチームを形成し、IDE、バージョン管理、CI/CD、コンテナ環境、品質ツール、テストフレームワークと、最も多様なツールチェーンを使いこなす必要があります。人件費がプロジェクト最大のコスト項目となるのもこの工程であり、開発効率の最適化がそのままプロジェクトコストに直結します。

| カテゴリ | リソース                 | 備考                                         |
| -------- | ------------------------ | -------------------------------------------- |
| **人**   | フロントエンドエンジニア | UI/コンポーネント実装                        |
| **人**   | バックエンドエンジニア   | API/ビジネスロジック実装                     |
| **人**   | フルスタックエンジニア   | 横断的な実装                                 |
| **人**   | テックリード             | コードレビュー、技術的意思決定               |
| **人**   | DevOpsエンジニア         | CI/CD・開発環境整備                          |
| **物**   | IDE / エディタ           | VS Code, IntelliJ, WebStorm 等               |
| **物**   | バージョン管理           | Git（GitHub / GitLab / Bitbucket）           |
| **物**   | CI/CDツール              | GitHub Actions, GitLab CI, Jenkins, CircleCI |
| **物**   | パッケージマネージャ     | npm / yarn / pnpm, NuGet, pip 等             |
| **物**   | コンテナ環境             | Docker, Docker Compose                       |
| **物**   | コード品質ツール         | ESLint, Prettier, SonarQube, Stylelint       |
| **物**   | テストフレームワーク     | Jasmine, Jest, xUnit, Cypress 等             |
| **物**   | コミュニケーションツール | Slack, Teams, Discord                        |
| **金**   | 開発者人件費             | プロジェクト最大のコスト項目                 |
| **金**   | クラウド開発環境費       | Dev/Staging環境のランニングコスト            |
| **金**   | SaaSツール費             | GitHub, Jira, Figma 等のサブスクリプション   |

### 成果物

実装・開発の成果物は、他の工程のドキュメントベースの成果物とは本質的に異なり、「実行可能なソフトウェア」そのものです。ソースコード、テストコード、CI/CDパイプライン設定、DBマイグレーションファイルなど、すべてがコードとしてバージョン管理されます。APIドキュメントもOpenAPI仕様から自動生成されるのが理想的で、「ドキュメントとコードが乖離しない」仕組みを成果物レベルで担保することが重要です。

| 成果物                       | 形式                 | 必須/任意 |
| ---------------------------- | -------------------- | --------- |
| ソースコード                 | Git リポジトリ       | 必須      |
| 単体テストコード             | テストファイル       | 必須      |
| テストカバレッジレポート     | HTML / レポート      | 任意      |
| CI/CDパイプライン設定        | YAML / 設定ファイル  | 必須      |
| DB マイグレーションファイル  | SQL / スクリプト     | 必須      |
| API ドキュメント（自動生成） | OpenAPI / Swagger UI | 必須      |
| コードレビュー記録           | PR / MRのコメント    | 必須      |

## 6. テスト

### 目的

ソフトウェアが要件を満たし、品質基準をクリアしていることを検証する。

テスト工程は、開発した成果物が期待通りに動作するかを体系的に検証する工程です。単体テストから始まり、結合テスト、システムテスト、受入テスト（UAT）と、段階的に検証の範囲を広げていきます。機能面の検証だけでなく、性能テストやセキュリティ診断といった非機能テストも重要です。テストで発見された不具合は優先度をつけて管理し、修正後に再テストを実施します。テスト自動化を取り入れることで、回帰テストの効率化と品質の継続的な担保が可能になります。

### テストレベルの全体像

テストは下位レベルから上位レベルへと段階的に実施します。下位のテストほど実行頻度が高く自動化しやすい一方、上位のテストほどビジネス要件に近い検証が行えます。各レベルで検出できる不具合の種類が異なるため、すべてのレベルをバランスよく実施することが品質確保の鍵です。

```mermaid
graph BT
    UT["単体テスト（Unit Test）"] --> IT["結合テスト（Integration Test）"]
    IT --> ST["システムテスト（System Test）"]
    ST --> UAT["受入テスト（UAT）"]

    UT -.- UT_DESC["関数・メソッド単位の検証"]
    IT -.- IT_DESC["モジュール間連携の検証"]
    ST -.- ST_DESC["システム全体の品質検証"]
    UAT -.- UAT_DESC["ビジネス要件の充足確認"]

    style UT fill:#3498DB,color:#fff
    style IT fill:#2ECC71,color:#fff
    style ST fill:#E74C3C,color:#fff
    style UAT fill:#9B59B6,color:#fff
```

### タスク一覧

テスト工程のタスクは、「計画→設計→準備→実行→報告」という体系的なプロセスで構成されます。実装・開発が「作る」活動であるのに対し、テストは「壊れる条件を探す」活動であり、必要なマインドセットが根本的に異なります。テストレベル（単体・結合・システム・受入）ごとに検証対象・手法・ツールが異なり、それぞれに固有の専門知識が求められます。特にセキュリティテストや性能テストは高度に専門的で、外部の専門家に委託するケースも少なくありません。

| #   | タスク             | テストレベル | 説明                                             |
| --- | ------------------ | ------------ | ------------------------------------------------ |
| 1   | テスト計画策定     | 全体         | テスト方針・スケジュール・体制・環境の計画       |
| 2   | テストケース設計   | 全体         | テスト条件・手順・期待結果の文書化               |
| 3   | テストデータ準備   | 全体         | テスト用データの作成・匿名化・投入               |
| 4   | テスト環境構築     | 全体         | Staging/QA環境のセットアップ                     |
| 5   | 単体テスト実行     | Unit         | 関数・メソッド単位の自動テスト                   |
| 6   | 結合テスト実行     | Integration  | API連携・モジュール間の結合検証                  |
| 7   | システムテスト実行 | System       | 機能テスト・非機能テスト（性能・セキュリティ等） |
| 8   | 回帰テスト         | System       | 既存機能への影響がないことの確認                 |
| 9   | 受入テスト実行     | UAT          | ビジネス要件に対するユーザー視点の検証           |
| 10  | バグ管理・修正     | 全体         | 不具合の起票・優先度付け・修正・再テスト         |
| 11  | テスト結果報告     | 全体         | テスト結果・品質メトリクスの集計・報告           |

### リソース

テスト工程では、QAエンジニアが主導的な役割を担います。実装工程で開発エンジニアが主役だったのに対し、ここでは品質保証の専門家が中心となります。さらに、受入テスト（UAT）ではエンドユーザー代表が参加し、ビジネス要件の充足を直接検証します。ツールもテスト管理、自動テスト、性能テスト、セキュリティ診断とテストの種類ごとに専用のものが必要であり、テスト環境（Staging/QA）の構築・維持コストも発生します。

| カテゴリ | リソース                    | 備考                               |
| -------- | --------------------------- | ---------------------------------- |
| **人**   | QAエンジニア / テストリード | テスト計画・設計の責任者           |
| **人**   | テストエンジニア            | テスト実行・バグ報告               |
| **人**   | 開発エンジニア              | バグ修正・単体テスト               |
| **人**   | エンドユーザー代表          | UAT実施                            |
| **人**   | セキュリティテスター        | 脆弱性診断（必要時）               |
| **人**   | 性能テストエンジニア        | 負荷テスト（必要時）               |
| **物**   | テスト管理ツール            | TestRail, Zephyr, スプレッドシート |
| **物**   | バグ管理ツール              | Jira, Backlog, GitHub Issues       |
| **物**   | 自動テストツール            | Cypress, Playwright, Selenium      |
| **物**   | 性能テストツール            | JMeter, k6, Locust                 |
| **物**   | セキュリティ診断ツール      | OWASP ZAP, Burp Suite              |
| **物**   | テスト環境                  | Staging / QA 環境                  |
| **金**   | QA人件費                    | テスター工数                       |
| **金**   | テスト環境費用              | クラウドインフラ費                 |
| **金**   | 外部診断費用                | 第三者によるセキュリティ診断等     |

### 成果物

テスト工程の成果物は、リリース可否を判断するための「エビデンス」です。テスト計画書でテスト方針を定め、テストケースで検証内容を明確化し、テスト結果報告書で品質の客観的な証拠を提示する — この一連のドキュメントが「このソフトウェアはリリースしてよい」という合理的根拠を構成します。バグ一覧は次工程以降で継続的に管理される「生きたドキュメント」です。

| 成果物                 | 形式                        | 必須/任意 |
| ---------------------- | --------------------------- | --------- |
| テスト計画書           | ドキュメント                | 必須      |
| テストケース一覧       | スプレッドシート / ツール   | 必須      |
| テスト結果報告書       | ドキュメント                | 必須      |
| バグ一覧・管理表       | チケット / スプレッドシート | 必須      |
| 品質メトリクスレポート | レポート                    | 任意      |
| 性能テスト結果報告書   | ドキュメント                | 任意      |
| セキュリティ診断報告書 | ドキュメント                | 任意      |

## 7. デプロイ・リリース

### 目的

開発した成果物を本番環境に安全に展開し、ユーザーが利用可能にする。

デプロイ・リリースは、開発・テストを終えたソフトウェアを実際にユーザーが使える状態にする工程です。本番環境への展開は、システム障害のリスクが最も高いタイミングの一つであるため、入念な計画とロールバック手順の準備が欠かせません。Blue-Green デプロイやカナリアリリースなどの戦略を採用することで、リスクを最小限に抑えながら段階的に展開できます。また、監視・アラートの設定をリリースと同時に整備し、問題発生時の迅速な検知・対応を可能にします。

### タスク一覧

デプロイ・リリースのタスクは、技術的作業とコミュニケーション作業の両面で構成されます。環境構築やデプロイ実行といったインフラ操作に加え、リリースノート作成やステークホルダー通知、ユーザートレーニングといった「人に届ける」活動が含まれるのが他の技術工程と異なる特徴です。また、ロールバック手順やスモークテストなど、障害発生を前提とした「防御的タスク」が多いのも、この工程のリスク特性を反映しています。

| #   | タスク                   | 説明                                             |
| --- | ------------------------ | ------------------------------------------------ |
| 1   | リリース計画策定         | リリース日時・手順・ロールバック計画の策定       |
| 2   | 本番環境構築・確認       | インフラのプロビジョニング・設定確認             |
| 3   | デプロイ手順書作成       | デプロイ手順・チェックリストの文書化             |
| 4   | DBマイグレーション実行   | 本番DBへのスキーマ変更・データ移行               |
| 5   | アプリケーションデプロイ | ビルド・デプロイの実行（Blue-Green / Canary 等） |
| 6   | スモークテスト           | 本番環境での基本動作確認                         |
| 7   | 監視設定                 | アラート・ダッシュボード・ログ収集の設定         |
| 8   | リリースノート作成       | 変更内容・既知の問題の文書化                     |
| 9   | ステークホルダー通知     | 関係者への完了通知・変更案内                     |
| 10  | ユーザートレーニング     | エンドユーザー向け研修・マニュアル配布           |

### リソース

デプロイ・リリースでは、開発チームからDevOps/SREエンジニアへと主導権が移行します。開発者は問題発生時の待機要員となり、リリースマネージャーが全体の調整を行います。ツールもCI/CDパイプライン、IaC（Infrastructure as Code）、コンテナオーケストレーション、監視ツールなど、インフラ運用系が中心になります。コスト面では、本番環境のインフラ費用やドメイン・SSL証明書など、サービス提供に直接必要な継続的費用が発生し始めるのがこの工程の大きな転換点です。

| カテゴリ | リソース                     | 備考                                    |
| -------- | ---------------------------- | --------------------------------------- |
| **人**   | リリースマネージャー         | リリース全体の調整・判断                |
| **人**   | DevOps / SREエンジニア       | デプロイ実行、インフラ管理              |
| **人**   | 開発エンジニア               | デプロイ時の問題対応                    |
| **人**   | QAエンジニア                 | スモークテスト実行                      |
| **人**   | サポート担当                 | ユーザー問い合わせ対応準備              |
| **物**   | CI/CDパイプライン            | 自動デプロイ環境                        |
| **物**   | IaCツール                    | Terraform, CloudFormation, Pulumi       |
| **物**   | コンテナオーケストレーション | Kubernetes, ECS, Cloud Run              |
| **物**   | 監視ツール                   | Datadog, New Relic, Grafana, CloudWatch |
| **物**   | ログ管理                     | ELK Stack, Loki, CloudWatch Logs        |
| **金**   | 本番インフラ費用             | クラウドサービス利用料                  |
| **金**   | ドメイン・SSL証明書          | 年間費用                                |
| **金**   | CDN費用                      | CloudFront, Cloudflare 等               |

### 成果物

デプロイ・リリースの成果物は、「手順書とチェックリスト」が中心です。リリース計画書、デプロイ手順書、ロールバック手順書は、本番環境で問題が起きた際に冷静に対処するための命綱です。また、監視ダッシュボードは運用・保守フェーズに引き継がれる重要なインフラであり、リリース時点で整備されていなければならない成果物です。ユーザーマニュアルやトレーニング資料は、利用者への価値提供を完結させるための最後のピースとなります。

| 成果物             | 形式            | 必須/任意 |
| ------------------ | --------------- | --------- |
| リリース計画書     | ドキュメント    | 必須      |
| デプロイ手順書     | ドキュメント    | 必須      |
| リリースノート     | ドキュメント    | 必須      |
| ロールバック手順書 | ドキュメント    | 必須      |
| スモークテスト結果 | チェックリスト  | 必須      |
| 監視ダッシュボード | ツール設定      | 必須      |
| ユーザーマニュアル | ドキュメント    | 任意      |
| トレーニング資料   | スライド / 動画 | 任意      |

## 8. 運用・保守

### 目的

リリース後のシステムを安定的に稼働させ、継続的に価値を提供し続ける。

運用・保守は、プロジェクトの「完了後」に始まる最も長期にわたる工程です。システムの監視、障害対応、セキュリティパッチの適用、バグ修正、ユーザーサポートなど、多岐にわたる活動が日々発生します。また、ユーザーからのフィードバックに基づく機能改善や、ライブラリ更新・EOL対応といった技術的負債の返済も重要な責務です。運用コストはプロジェクト全体のライフサイクルで最大の割合を占めることが多く、効率的な運用体制の構築が長期的なサービスの持続性を左右します。

### タスク一覧

運用・保守のタスクは、他の全工程と根本的に性質が異なります。前工程が「計画的・プロアクティブ」な活動であるのに対し、運用・保守は「障害対応やバグ修正」といったリアクティブな活動と、「セキュリティパッチ適用や技術的負債の返済」といった予防的な活動の両面を持ちます。タスクの範囲もインシデント管理からユーザーサポート、コスト最適化まで極めて広く、特定の一つの専門性では対応しきれない「総合力」が求められる工程です。

| #   | タスク                       | 説明                                               |
| --- | ---------------------------- | -------------------------------------------------- |
| 1   | 障害対応（インシデント管理） | 障害検知→対応→復旧→原因分析→再発防止               |
| 2   | 監視・アラート対応           | 死活監視、性能監視、異常検知への対応               |
| 3   | バグ修正（パッチ）           | ユーザー報告・内部発見のバグ修正                   |
| 4   | セキュリティパッチ適用       | 脆弱性情報の収集・パッチ適用                       |
| 5   | 定期メンテナンス             | OS/ミドルウェアのアップデート、証明書更新等        |
| 6   | バックアップ・DR             | バックアップの取得・検証、災害復旧訓練             |
| 7   | 性能チューニング             | ボトルネック分析・最適化                           |
| 8   | ユーザーサポート             | 問い合わせ対応、FAQ更新                            |
| 9   | 機能改善・エンハンスメント   | ユーザーフィードバックに基づく改善開発             |
| 10  | 技術的負債の返済             | ライブラリ更新、リファクタリング、EOL対応          |
| 11  | SLA/SLOモニタリング          | 稼働率・応答時間等のサービスレベルの監視           |
| 12  | コスト最適化                 | 不要リソースの削除、リザーブドインスタンスの活用等 |

### リソース

運用・保守のリソースは、他のどの工程とも異なる特徴を持ちます。第一に、コストが「一度きり」ではなく「継続的」に発生する点です。月額のインフラ費用、保守人件費、SaaSツール費は、サービスが存続する限り毎月必要です。第二に、SREエンジニア、運用エンジニア、開発エンジニア、カスタマーサポート、セキュリティ担当と、異なる専門性を持つ人材が常時必要な点です。このクロスファンクショナルな体制構築が、安定運用の前提条件になります。

| カテゴリ | リソース               | 備考                            |
| -------- | ---------------------- | ------------------------------- |
| **人**   | SREエンジニア          | システム信頼性の維持            |
| **人**   | 運用エンジニア         | 日常運用・監視対応              |
| **人**   | 開発エンジニア         | バグ修正・機能改善              |
| **人**   | カスタマーサポート     | ユーザー問い合わせ対応          |
| **人**   | セキュリティ担当       | 脆弱性管理・インシデント対応    |
| **物**   | 監視ツール             | Datadog, PagerDuty, Grafana     |
| **物**   | インシデント管理ツール | PagerDuty, OpsGenie, Statuspage |
| **物**   | ログ分析ツール         | ELK, Splunk, Loki               |
| **物**   | バックアップツール     | AWS Backup, Velero 等           |
| **物**   | チケット管理ツール     | Jira Service Desk, Zendesk      |
| **金**   | インフラ運用費         | 月額クラウド費用（継続的）      |
| **金**   | 保守人件費             | エンジニア工数（継続的）        |
| **金**   | サポートツール費       | SaaSツールのサブスクリプション  |
| **金**   | 障害対応予備費         | 緊急対応用の予算枠              |

### 成果物

運用・保守の成果物は「生きたドキュメント」、つまり継続的に更新され続ける点が最大の特徴です。運用マニュアルやRunbookは障害のたびに改善され、インシデントレポートは発生のたびに追加され、SLA/SLOレポートは定期的に作成されます。一度作ったら完了する他の工程の成果物とは根本的に異なり、ドキュメントの鮮度維持が運用品質に直結します。改善提案書は、運用で得た知見を次の開発サイクルにフィードバックする橋渡しの役割を担います。

| 成果物                    | 形式                 | 必須/任意 |
| ------------------------- | -------------------- | --------- |
| 運用マニュアル            | ドキュメント         | 必須      |
| 障害対応手順書（Runbook） | ドキュメント         | 必須      |
| インシデントレポート      | ドキュメント（随時） | 必須      |
| SLA/SLOレポート           | レポート（定期）     | 必須      |
| 変更管理記録              | チケット / ログ      | 必須      |
| 月次運用レポート          | ドキュメント         | 任意      |
| 改善提案書                | ドキュメント         | 任意      |

## 横断的な活動（全工程共通）

ソフトウェア開発では、各工程固有のタスクだけでなく、プロジェクト全体を通じて継続的に行うべき活動があります。プロジェクト管理、品質管理、セキュリティ管理、コミュニケーションなどがこれにあたります。これらの横断的活動は、特定の工程に限定されず、プロジェクトの開始から終了まで一貫して実施されます。

```mermaid
mindmap
  root((横断的活動))
    プロジェクト管理
      スケジュール管理
      リスク管理
      課題管理
      進捗報告
      変更管理
    品質管理
      コードレビュー
      静的解析
      テスト自動化
      品質メトリクス収集
    コミュニケーション
      デイリースタンドアップ
      ステークホルダー報告
      振り返り（レトロスペクティブ）
      ナレッジ共有
    セキュリティ
      脅威モデリング
      SAST/DAST
      依存関係監査
      アクセス管理
    ドキュメント
      設計書更新
      API仕様書
      運用手順書
      ナレッジベース
```

### 横断的活動の詳細

| 活動                       | 主要タスク                                            | 必要なリソース（人）  | 必要なツール（物）          | コスト（金） |
| -------------------------- | ----------------------------------------------------- | --------------------- | --------------------------- | ------------ |
| **プロジェクト管理**       | WBS作成、進捗管理、リスク管理、ステアリングコミッティ | PM / スクラムマスター | Jira, Backlog, MS Project   | PM人件費     |
| **品質管理**               | レビュー、メトリクス収集、品質基準策定                | QAリード              | SonarQube, CodeClimate      | ツール費     |
| **構成管理**               | バージョン管理、ブランチ戦略、リリース管理            | DevOps                | Git, GitHub/GitLab          | SaaS費       |
| **セキュリティ管理**       | 脅威分析、脆弱性管理、アクセス制御                    | セキュリティ担当      | Snyk, Dependabot, OWASP ZAP | 診断費       |
| **コミュニケーション管理** | 会議運営、報告、ドキュメント共有                      | PM / 全メンバー       | Slack, Teams, Confluence    | SaaS費       |
| **リスク管理**             | リスク識別・評価・対策・監視                          | PM / リード           | リスク管理台帳              | 対策費       |
| **変更管理**               | 変更要求の受付・影響評価・承認・実行                  | PM / CCB              | チケット管理ツール          | 追加開発費   |
| **ナレッジ管理**           | 知見の記録・共有・活用                                | 全メンバー            | Confluence, Notion, Wiki    | SaaS費       |

## 工程別コスト配分の目安

プロジェクトの予算策定やリソース計画を立てる際、各工程にどの程度のコストがかかるかの目安を知っておくことは有用です。以下は一般的なソフトウェア開発プロジェクトにおける工程別のコスト配分の目安です。実装・開発が最大の割合を占めるのが一般的ですが、テストや運用・保守にも相当のコストがかかることを見落としがちなので注意が必要です。

```mermaid
pie title 工程別コスト配分（目安）
    "企画・構想" : 5
    "要件定義" : 10
    "基本設計" : 10
    "詳細設計" : 10
    "実装・開発" : 35
    "テスト" : 15
    "デプロイ・リリース" : 5
    "運用・保守（初年度）" : 10
```

> ※ 上記はあくまで一般的な目安です。プロジェクトの規模・性質・契約形態により大きく変動します。

## 工程別リスクマップ

各工程には固有のリスクが存在します。リスクを事前に認識し、適切な対策を講じておくことで、プロジェクトの失敗確率を大幅に下げることができます。以下の表は、各工程の代表的なリスクとその対策をまとめたものです。

| 工程       | 代表的リスク             | 影響度 | 対策                               |
| ---------- | ------------------------ | ------ | ---------------------------------- |
| 企画・構想 | ビジネスケースの見誤り   | 高     | PoC実施、市場調査の徹底            |
| 要件定義   | 要件の漏れ・曖昧さ       | 高     | プロトタイピング、ユーザーレビュー |
| 基本設計   | アーキテクチャの選定ミス | 高     | ADR、技術検証、レビュー            |
| 詳細設計   | 過度な設計 / 設計不足    | 中     | YAGNI原則、設計レビュー            |
| 実装・開発 | 技術的負債の蓄積         | 中     | コードレビュー、リファクタリング   |
| テスト     | テスト不足による品質問題 | 高     | テスト自動化、カバレッジ監視       |
| デプロイ   | デプロイ失敗・本番障害   | 高     | ロールバック手順、段階的リリース   |
| 運用・保守 | 属人化・知識の散逸       | 中     | ドキュメント整備、ナレッジ共有     |

## アジャイル vs ウォーターフォールでの工程の扱い方の違い

ここまで整理してきた8つの工程は、開発方法論によらず普遍的に存在するものです。ただし、ウォーターフォールでは各工程を順番に完了させてから次へ進むのに対し、アジャイル（スクラム等）ではスプリントの中で複数の工程を小さく反復して回すという点が根本的に異なります。以下でその違いを比較します。

```mermaid
graph LR
    subgraph WF["ウォーターフォール"]
        direction LR
        W1["企画"] --> W2["要件"] --> W3["設計"] --> W4["実装"] --> W5["テスト"] --> W6["リリース"]
    end

    subgraph AG["アジャイル（スクラム）"]
        direction LR
        A1["プロダクト<br>バックログ"]
        A1 --> S1["Sprint 1<br>設計→実装→テスト"]
        A1 --> S2["Sprint 2<br>設計→実装→テスト"]
        A1 --> S3["Sprint 3<br>設計→実装→テスト"]
        S1 --> R1["リリース"]
        S2 --> R1
        S3 --> R1
    end
```

| 観点         | ウォーターフォール             | アジャイル                                  |
| ------------ | ------------------------------ | ------------------------------------------- |
| 工程の進め方 | 逐次的・前工程完了後に次へ     | 反復的・各スプリント内で全工程を小さく回す  |
| 要件定義     | プロジェクト初期に網羅的に実施 | バックログとして段階的に詳細化              |
| 設計         | 事前に全体を詳細設計           | 必要十分な設計を都度実施（YAGNI）           |
| テスト       | 開発後にまとめて実施           | 開発と同時に継続的に実施（TDD/BDD）         |
| リリース     | プロジェクト終盤に一括         | スプリントごとにインクリメンタルに          |
| 成果物の粒度 | 大量の公式ドキュメント         | 動くソフトウェア + 必要最小限のドキュメント |
| 変更への対応 | 変更管理プロセスを経て対応     | バックログの再優先順位付けで柔軟に対応      |

## まとめ

ソフトウェア開発は、方法論によらず「企画 → 要件定義 → 設計 → 実装 → テスト → リリース → 運用」の基本的な流れを辿ります。それぞれの工程には固有のタスク・リソース・成果物があり、横断的な管理活動がそれらを支えます。

重要なのは、これらの工程を自分たちのプロジェクトの文脈に合わせてテーラリング（最適化）することです。すべてを完璧にやろうとするのではなく、プロジェクトの規模・リスク・制約に応じて、適切な深さと形式で実施することが成功の鍵です。
